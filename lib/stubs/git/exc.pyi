from typing import Any, AnyStr, Optional, Sequence, Union

from .compat import safe_decode as safe_decode
from .repo import Repo

_CommandType = Union[str, Sequence[str]]

class GitError(Exception): ...
class InvalidGitRepositoryError(GitError): ...
class WorkTreeRepositoryUnsupported(InvalidGitRepositoryError): ...
class NoSuchPathError(GitError, OSError): ...

class CommandError(GitError):
    command: _CommandType = ...
    status: Any = ...
    stdout: Optional[str] = ...
    stderr: Optional[str] = ...
    def __init__(self, command: _CommandType, status: Optional[Any] = ..., stderr: Optional[str] = ..., stdout: Optional[str] = ...) -> None: ...

class GitCommandNotFound(CommandError):
    def __init__(self, command: _CommandType, cause: Any) -> None: ...

class GitCommandError(CommandError):
    def __init__(self, command: _CommandType, status: Any, stderr: Optional[str] = ..., stdout: Optional[str] = ...) -> None: ...

class CheckoutError(GitError):
    failed_files: Sequence[str] = ...
    failed_reasons: str = ...
    valid_files: Sequence[str] = ...
    def __init__(self, message: str, failed_files: Sequence[str], valid_files: Sequence[str], failed_reasons: str) -> None: ...

class CacheError(GitError): ...
class UnmergedEntriesError(CacheError): ...

class HookExecutionError(CommandError):
    def __init__(self, command: _CommandType, status: Any, stderr: Optional[str] = ..., stdout: Optional[str] = ...) -> None: ...

class RepositoryDirtyError(GitError):
    repo: Repo = ...
    message: str = ...
    def __init__(self, repo: Repo, message: str) -> None: ...
