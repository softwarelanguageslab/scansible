from typing import Any, Optional, Union, Iterator

Repo = Any #from ..repo import Repo
from ..objects.commit import Commit
from ..objects.base import Object
from .log import RefLog, RefLogEntry

class SymbolicReference:
    repo: Repo = ...
    path: str = ...
    def __init__(self, repo: Repo, path: str) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def name(self) -> str: ...
    @property
    def abspath(self) -> str: ...
    @classmethod
    def dereference_recursive(cls, repo: Repo, ref_path: str) -> str: ...

    @property
    def commit(self) -> Commit: ...
    @commit.setter
    def commit(self, commit: Union[str, Commit, SymbolicReference]) -> SymbolicReference: ...

    def set_commit(self, commit: Union[str, Commit, SymbolicReference], logmsg: Optional[str] = ...) -> SymbolicReference: ...

    @property
    def object(self) -> Object: ...
    @object.setter
    def object(self, object: Union[str, Object, SymbolicReference], logmsg: Optional[str] = ...) -> SymbolicReference: ...

    def set_object(self, object: Union[str, Object, SymbolicReference]) -> SymbolicReference: ...

    @property
    def reference(self) -> SymbolicReference: ...
    @reference.setter
    def reference(self, ref: Union[str, Object, SymbolicReference], logmsg: Optional[str] = ...) -> SymbolicReference: ...

    def set_reference(self, ref: Union[str, Object, SymbolicReference]) -> SymbolicReference: ...

    ref = reference

    def is_valid(self) -> bool: ...
    @property
    def is_detached(self) -> bool: ...
    def log(self) -> RefLog: ...
    def log_append(self, oldbinsha: bytes, message: str, newbinsha: Optional[bytes] = ...) -> RefLogEntry: ...
    def log_entry(self, index: int) -> RefLogEntry: ...
    @classmethod
    def to_full_path(cls, path: Union[SymbolicReference, str]) -> str: ...
    @classmethod
    def delete(cls, repo: Repo, path: Union[SymbolicReference, str]) -> None: ...
    @classmethod
    def create(cls, repo: Repo, path: str, reference: str = ..., force: bool = ..., logmsg: Optional[str] = ...) -> SymbolicReference: ...
    def rename(self, new_path: Union[SymbolicReference, str], force: bool = ...) -> SymbolicReference: ...
    @classmethod
    def iter_items(cls, repo: Repo, common_path: Optional[str] = ...) -> Iterator[SymbolicReference]: ...
    @classmethod
    def from_path(cls, repo: Repo, path: str) -> SymbolicReference: ...
    def is_remote(self) -> bool: ...
