from typing import Any, Sequence, Generic, TypeVar, Hashable, Iterator, overload, Literal

NodeT = TypeVar('NodeT', bound=Hashable)
GraphAttrT = TypeVar('GraphAttrT')
EdgeAttrT = TypeVar('EdgeAttrT')


class Graph(Generic[NodeT, GraphAttrT, EdgeAttrT]):
    # node_dict_factory: Incomplete
    # node_attr_dict_factory: Incomplete
    # adjlist_outer_dict_factory: Incomplete
    # adjlist_inner_dict_factory: Incomplete
    # edge_attr_dict_factory: Incomplete
    # graph_attr_dict_factory: Incomplete
    # def to_directed_class(self): ...
    # def to_undirected_class(self): ...
    graph: dict[str, GraphAttrT]
    # def __init__(self, incoming_graph_data: Incomplete | None = ..., **attr) -> None: ...
    # def adj(self): ...
    # @property
    # def name(self): ...
    # @name.setter
    # def name(self, s) -> None: ...
    def __iter__(self) -> Iterator[NodeT]: ...
    def __contains__(self, n: NodeT) -> bool: ...
    def __len__(self) -> int: ...
    # def __getitem__(self, n): ...
    def add_node(self, node_for_adding: NodeT, **attr: str) -> None: ...
    def add_nodes_from(self, nodes_for_adding: Sequence[NodeT], **attr: str) -> None: ...
    # def remove_node(self, n) -> None: ...
    # def remove_nodes_from(self, nodes) -> None: ...
    @overload
    def nodes(self) -> Iterator[NodeT]: ...
    @overload
    def nodes(self, data: Literal[True]) -> Iterator[tuple[NodeT, dict[str, str]]]: ...
    def number_of_nodes(self) -> int: ...
    def order(self) -> int: ...
    # def has_node(self, n): ...
    # def add_edge(self, u_of_edge, v_of_edge, **attr) -> None: ...
    # def add_edges_from(self, ebunch_to_add, **attr) -> None: ...
    # def add_weighted_edges_from(self, ebunch_to_add, weight: str = ..., **attr) -> None: ...
    # def remove_edge(self, u, v) -> None: ...
    # def remove_edges_from(self, ebunch) -> None: ...
    # def update(self, edges: Incomplete | None = ..., nodes: Incomplete | None = ...) -> None: ...
    # def has_edge(self, u: NodeT, v: NodeT) -> bool: ...
    # def neighbors(self, n): ...
    # def edges(self): ...
    # def get_edge_data(self, u: Any, v: Any, default: Incomplete | None = ...): ...
    # def adjacency(self): ...
    # def degree(self): ...
    # def clear(self) -> None: ...
    # def clear_edges(self) -> None: ...
    # def is_multigraph(self): ...
    # def is_directed(self): ...
    # def copy(self, as_view: bool = ...): ...
    # def to_directed(self, as_view: bool = ...): ...
    # def to_undirected(self, as_view: bool = ...): ...
    # def subgraph(self, nodes): ...
    # def edge_subgraph(self, edges): ...
    # def size(self, weight: Incomplete | None = ...): ...
    @overload
    def number_of_edges(self) -> int: ...
    @overload
    def number_of_edges(self, u: NodeT, v: NodeT) -> int: ...
    # def nbunch_iter(self, nbunch: Incomplete | None = ...): ...
